/* A recursive-descent parser generated by greg 0.4.6 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct _GREG;
#define YYRULECOUNT 18

#include "parser.h"

#ifndef YY_ALLOC
#define YY_ALLOC(N, D) malloc(N)
#endif
#ifndef YY_CALLOC
#define YY_CALLOC(N, S, D) calloc(N, S)
#endif
#ifndef YY_REALLOC
#define YY_REALLOC(B, N, D) realloc(B, N)
#endif
#ifndef YY_FREE
#define YY_FREE free
#endif
#ifndef YY_LOCAL
#define YY_LOCAL(T)     static T
#endif
#ifndef YY_ACTION
#define YY_ACTION(T)    static T
#endif
#ifndef YY_RULE
#define YY_RULE(T)      static T
#endif
#ifndef YY_PARSE
#define YY_PARSE(T)     T
#endif
#ifndef YY_NAME
#define YY_NAME(N) yy##N
#endif
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size, D)		\
  {							\
    int yyc= getchar();					\
    result= (EOF == yyc) ? 0 : (*(buf)= yyc, 1);	\
    yyprintf((stderr, "<%c>", yyc));			\
  }
#endif
#ifndef YY_BEGIN
#define YY_BEGIN        ( G->begin= G->pos, 1)
#endif
#ifndef YY_END
#define YY_END          ( G->end= G->pos, 1)
#endif
#ifdef YY_DEBUG
# ifndef DEBUG_PARSE
#  define DEBUG_PARSE   1
# endif
# ifndef DEBUG_VERBOSE
#  define DEBUG_VERBOSE 2
# endif
# define yyprintf(args)	         if (G->debug & DEBUG_PARSE)         fprintf args
# define yyprintfv(args)         if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) fprintf args
# define yyprintfGcontext        if (G->debug & DEBUG_PARSE)         yyprintcontext(stderr,G->buf+G->pos)
# define yyprintfvGcontext       if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) yyprintcontext(stderr,G->buf+G->pos)
# define yyprintfvTcontext(text) if (G->debug == (DEBUG_PARSE|DEBUG_VERBOSE)) yyprintcontext(stderr,text)
#else
# define yyprintf(args)
# define yyprintfv(args)
# define yyprintfGcontext
# define yyprintfvGcontext
# define yyprintfvTcontext(text)
#endif
#ifndef YYSTYPE
#define YYSTYPE int
#endif
#ifndef YY_XTYPE
#define YY_XTYPE void *
#endif
#ifndef YY_XVAR
#define YY_XVAR yyxvar
#endif

#ifndef YY_STACK_SIZE
#define YY_STACK_SIZE 128
#endif

#ifndef YY_BUFFER_START_SIZE
#define YY_BUFFER_START_SIZE 1024
#endif

#ifndef YY_PART
#define yydata G->data
#define yy G->ss

struct _yythunk; /* forward declaration */
typedef void (*yyaction)(struct _GREG *G, char *yytext, int yyleng, struct _yythunk *thunkpos, YY_XTYPE YY_XVAR);
typedef struct _yythunk { int begin, end;  yyaction  action; const char *name; struct _yythunk *next; } yythunk;

typedef struct _GREG {
  char *buf;
  int buflen;
  int   offset;
  int   pos;
  int   limit;
  char *text;
  int   textlen;
  int   begin;
  int   end;
  yythunk *thunks;
  int   thunkslen;
  int thunkpos;
  YYSTYPE ss;
  YYSTYPE *val;
  YYSTYPE *vals;
  int valslen;
  YY_XTYPE data;
#ifdef YY_DEBUG
  int debug;
#endif
} GREG;

YY_LOCAL(int) yyrefill(GREG *G)
{
  int yyn;
  while (G->buflen - G->pos < 512)
    {
      G->buflen *= 2;
      G->buf= (char*)YY_REALLOC(G->buf, G->buflen, G->data);
    }
  YY_INPUT((G->buf + G->pos), yyn, (G->buflen - G->pos), G->data);
  if (!yyn) return 0;
  G->limit += yyn;
  return 1;
}

YY_LOCAL(int) yymatchDot(GREG *G)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  ++G->pos;
  return 1;
}

#ifdef YY_DEBUG
YY_LOCAL(void) yyprintcontext(FILE *stream, char *s)
{
  char *context = s;
  char *nl = strchr(context, 10);
  if (nl) {
    context = (char*)malloc(nl-s+1);
    strncpy(context, s, nl-s);
    context[nl-s] = '\0'; /* replace nl by 0 */
  }
  fprintf(stream, " @ \"%s\"", context);
  if (nl) free(context);
}
#endif

YY_LOCAL(int) yymatchChar(GREG *G, int c)
{
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  if ((unsigned char)G->buf[G->pos] == c)
    {
      ++G->pos;
      if (c<32) { yyprintf((stderr, "  ok   yymatchChar '0x%x'", c));}
      else      { yyprintf((stderr, "  ok   yymatchChar '%c'", c));}
      yyprintfGcontext;
      yyprintf((stderr, "\n"));
      return 1;
    }
  if (c<32) { yyprintfv((stderr, "  fail yymatchChar '0x%x'", c));}
  else      { yyprintfv((stderr, "  fail yymatchChar '%c'", c));}
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));
  return 0;
}

YY_LOCAL(int) yymatchString(GREG *G, const char *s)
{
  int yysav= G->pos;
  while (*s)
    {
      if (G->pos >= G->limit && !yyrefill(G)) return 0;
      if (G->buf[G->pos] != *s)
        {
          G->pos= yysav;
          return 0;
        }
      ++s;
      ++G->pos;
    }
  return 1;
}

YY_LOCAL(int) yymatchClass(GREG *G, const unsigned char *bits, const char *cclass)
{
  int c;
  if (G->pos >= G->limit && !yyrefill(G)) return 0;
  c= (unsigned char)G->buf[G->pos];
  if (bits[c >> 3] & (1 << (c & 7)))
    {
      ++G->pos;
      yyprintf((stderr, "  ok   yymatchClass [%s]", cclass));
      yyprintfGcontext;
      yyprintf((stderr, "\n"));
      return 1;
    }
  yyprintfv((stderr, "  fail yymatchClass [%s]", cclass));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));
  return 0;
}

YY_LOCAL(void) yyDo(GREG *G, yyaction action, int begin, int end, const char *name)
{
  while (G->thunkpos >= G->thunkslen)
    {
      G->thunkslen *= 2;
      G->thunks= (yythunk*)YY_REALLOC(G->thunks, sizeof(yythunk) * G->thunkslen, G->data);
    }
  G->thunks[G->thunkpos].begin=  begin;
  G->thunks[G->thunkpos].end=    end;
  G->thunks[G->thunkpos].action= action;
  G->thunks[G->thunkpos].name= name;
  ++G->thunkpos;
}

YY_LOCAL(int) yyText(GREG *G, int begin, int end)
{
  int yyleng= end - begin;
  if (yyleng <= 0)
    yyleng= 0;
  else
    {
      while (G->textlen < (yyleng + 1))
        {
          G->textlen *= 2;
          G->text= (char*)YY_REALLOC(G->text, G->textlen, G->data);
        }
      memcpy(G->text, G->buf + begin, yyleng);
    }
  G->text[yyleng]= '\0';
  return yyleng;
}

YY_LOCAL(void) yyDone(GREG *G)
{
  int pos;
  for (pos= 0; pos < G->thunkpos; ++pos)
    {
      yythunk *thunk= &G->thunks[pos];
      int yyleng= thunk->end ? yyText(G, thunk->begin, thunk->end) : thunk->begin;
      yyprintf((stderr, "DO [%d] %s", pos, thunk->name));
      yyprintfvTcontext(G->text);
      yyprintf((stderr, "\n"));
      thunk->action(G, G->text, yyleng, thunk, G->data);
    }
  G->thunkpos= 0;
}

YY_LOCAL(void) yyCommit(GREG *G)
{
  if ((G->limit -= G->pos))
    {
      memmove(G->buf, G->buf + G->pos, G->limit);
    }
  G->offset += G->pos;
  G->begin -= G->pos;
  G->end -= G->pos;
  G->pos= G->thunkpos= 0;
}

YY_LOCAL(int) yyAccept(GREG *G, int tp0)
{
  if (tp0)
    {
      fprintf(stderr, "accept denied at %d\n", tp0);
      return 0;
    }
  else
    {
      yyDone(G);
      yyCommit(G);
    }
  return 1;
}

YY_LOCAL(void) yyPush(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{
  size_t off = (G->val - G->vals) + count;
  if (off > G->valslen) {
    while (G->valslen < off + 1)
      G->valslen *= 2;
    G->vals= (YYSTYPE*)YY_REALLOC((void *)G->vals, sizeof(YYSTYPE) * G->valslen, G->data);
    G->val= G->vals + off;
  } else {
    G->val += count;
  }
}
YY_LOCAL(void) yyPop(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{ G->val -= count; }
YY_LOCAL(void) yySet(GREG *G, char *text, int count, yythunk *thunk, YY_XTYPE YY_XVAR)	{ G->val[count]= G->ss; }

#endif /* YY_PART */

#define YYACCEPT        yyAccept(G, yythunkpos0)

YY_RULE(int) yy_kw(GREG *G); /* 18 */
YY_RULE(int) yy_primary(GREG *G); /* 17 */
YY_RULE(int) yy_unary(GREG *G); /* 16 */
YY_RULE(int) yy_product(GREG *G); /* 15 */
YY_RULE(int) yy_sum(GREG *G); /* 14 */
YY_RULE(int) yy_expression(GREG *G); /* 13 */
YY_RULE(int) yy_clos_paren(GREG *G); /* 12 */
YY_RULE(int) yy_arg(GREG *G); /* 11 */
YY_RULE(int) yy_end_kw(GREG *G); /* 10 */
YY_RULE(int) yy_scope(GREG *G); /* 9 */
YY_RULE(int) yy_arg_list(GREG *G); /* 8 */
YY_RULE(int) yy_ID(GREG *G); /* 7 */
YY_RULE(int) yy__(GREG *G); /* 6 */
YY_RULE(int) yy_func_decl(GREG *G); /* 5 */
YY_RULE(int) yy_EOL(GREG *G); /* 4 */
YY_RULE(int) yy_WS(GREG *G); /* 3 */
YY_RULE(int) yy_module_core(GREG *G); /* 2 */
YY_RULE(int) yy_module(GREG *G); /* 1 */

YY_ACTION(void) yy_1_ID(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_ID"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy = bfromcstr(yytext) }\n"));
  yy = bfromcstr(yytext) ;
}
YY_ACTION(void) yy_1_unary(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define r G->val[-1]
  yyprintf((stderr, "do yy_1_unary"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy = r }\n"));
  yy = r ;
#undef r
}
YY_ACTION(void) yy_1_expression(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define s G->val[-1]
  yyprintf((stderr, "do yy_1_expression"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {yy = s }\n"));
  yy = s ;
#undef s
}
YY_ACTION(void) yy_1_arg(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define name G->val[-1]
  yyprintf((stderr, "do yy_1_arg"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {pug_parser_on_argument(core->this, name) }\n"));
  pug_parser_on_argument(core->this, name) ;
#undef name
}
YY_ACTION(void) yy_2_func_decl(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define name G->val[-1]
  yyprintf((stderr, "do yy_2_func_decl"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {pug_parser_on_function_end(core->this) }\n"));
  pug_parser_on_function_end(core->this) ;
#undef name
}
YY_ACTION(void) yy_1_func_decl(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
#define name G->val[-1]
  yyprintf((stderr, "do yy_1_func_decl"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {pug_parser_on_function_start(core->this, name) }\n"));
  pug_parser_on_function_start(core->this, name) ;
#undef name
}
YY_ACTION(void) yy_1_module(GREG *G, char *yytext, int yyleng, yythunk *thunk, YY_XTYPE YY_XVAR)
{
  yyprintf((stderr, "do yy_1_module"));
  yyprintfvTcontext(yytext);
  yyprintf((stderr, "\n  {\n\
            if(core->eof) { return; }\n\
            tokenPos;\n\
            bstring message;\n\
            if(G->buf[core->token[0]] == _CBRACK) {\n\
              message = bfromcstr(\"Unmatched closing bracket\");\n\
            } else {\n\
              message = bfromcstr(\"Expected toplevel\");\n\
            }\n\
            throwTokenError(PPE_EXP_TOPLEVEL, message);\n\
          }\n"));
  
            if(core->eof) { return; }
            tokenPos;
            bstring message;
            if(G->buf[core->token[0]] == _CBRACK) {
              message = bfromcstr("Unmatched closing bracket");
            } else {
              message = bfromcstr("Expected toplevel");
            }
            throwTokenError(PPE_EXP_TOPLEVEL, message);
          ;
}

YY_RULE(int) yy_kw(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "kw"));
  if (!yy_end_kw(G))  goto l1;
  yyprintf((stderr, "  ok   kw"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l1:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "kw"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_primary(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "primary"));

  {  int yypos3= G->pos, yythunkpos3= G->thunkpos;  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l4;  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "0-9")) goto l4;

  l5:;	
  {  int yypos6= G->pos, yythunkpos6= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\377\003\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "0-9")) goto l6;
  goto l5;
  l6:;	  G->pos= yypos6; G->thunkpos= yythunkpos6;
  }  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l4;  goto l3;
  l4:;	  G->pos= yypos3; G->thunkpos= yythunkpos3;  if (!yy_ID(G))  goto l7;
  yyDo(G, yySet, 0, 0, "yySet");
  goto l3;
  l7:;	  G->pos= yypos3; G->thunkpos= yythunkpos3;  if (!yymatchChar(G, '(')) goto l2;
  if (!yy_expression(G))  goto l2;
  yyDo(G, yySet, 0, 0, "yySet");
  if (!yymatchChar(G, ')')) goto l2;

  }
  l3:;	  yyprintf((stderr, "  ok   primary"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l2:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "primary"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_unary(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "unary"));

  {  int yypos9= G->pos, yythunkpos9= G->thunkpos;  if (!yymatchChar(G, '+')) goto l10;
  if (!yy_WS(G))  goto l10;
  if (!yy_primary(G))  goto l10;
  yyDo(G, yySet, -1, 0, "yySet");
  goto l9;
  l10:;	  G->pos= yypos9; G->thunkpos= yythunkpos9;  if (!yymatchChar(G, '-')) goto l11;
  if (!yy_WS(G))  goto l11;
  if (!yy_primary(G))  goto l11;
  yyDo(G, yySet, -1, 0, "yySet");
  goto l9;
  l11:;	  G->pos= yypos9; G->thunkpos= yythunkpos9;  if (!yy_primary(G))  goto l8;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_unary, G->begin, G->end, "yy_1_unary");

  }
  l9:;	  yyprintf((stderr, "  ok   unary"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l8:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "unary"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_product(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "product"));
  if (!yy_unary(G))  goto l12;
  yyDo(G, yySet, 0, 0, "yySet");

  l13:;	
  {  int yypos14= G->pos, yythunkpos14= G->thunkpos;
  {  int yypos15= G->pos, yythunkpos15= G->thunkpos;  if (!yymatchChar(G, '*')) goto l16;
  if (!yy_WS(G))  goto l16;
  if (!yy_unary(G))  goto l16;
  yyDo(G, yySet, 0, 0, "yySet");
  goto l15;
  l16:;	  G->pos= yypos15; G->thunkpos= yythunkpos15;  if (!yymatchChar(G, '/')) goto l14;
  if (!yy_WS(G))  goto l14;
  if (!yy_unary(G))  goto l14;
  yyDo(G, yySet, 0, 0, "yySet");

  }
  l15:;	  goto l13;
  l14:;	  G->pos= yypos14; G->thunkpos= yythunkpos14;
  }  yyprintf((stderr, "  ok   product"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l12:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "product"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_sum(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 2, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "sum"));
  if (!yy_product(G))  goto l17;
  yyDo(G, yySet, 0, 0, "yySet");

  l18:;	
  {  int yypos19= G->pos, yythunkpos19= G->thunkpos;
  {  int yypos20= G->pos, yythunkpos20= G->thunkpos;  if (!yymatchChar(G, '+')) goto l21;
  if (!yy_WS(G))  goto l21;
  if (!yy_product(G))  goto l21;
  yyDo(G, yySet, 0, 0, "yySet");
  goto l20;
  l21:;	  G->pos= yypos20; G->thunkpos= yythunkpos20;  if (!yymatchChar(G, '-')) goto l19;
  if (!yy_WS(G))  goto l19;
  if (!yy_product(G))  goto l19;
  yyDo(G, yySet, 0, 0, "yySet");

  }
  l20:;	  goto l18;
  l19:;	  G->pos= yypos19; G->thunkpos= yythunkpos19;
  }  yyprintf((stderr, "  ok   sum"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 2, 0, "yyPop");
  return 1;
  l17:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "sum"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_expression(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "expression"));
  if (!yy_sum(G))  goto l22;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_expression, G->begin, G->end, "yy_1_expression");
  yyprintf((stderr, "  ok   expression"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l22:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "expression"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_clos_paren(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "clos_paren"));
  if (!yymatchChar(G, ')')) goto l23;
  yyprintf((stderr, "  ok   clos_paren"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l23:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "clos_paren"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_arg(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "arg"));
  if (!yy_ID(G))  goto l24;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_arg, G->begin, G->end, "yy_1_arg");
  yyprintf((stderr, "  ok   arg"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l24:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "arg"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_end_kw(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "end_kw"));
  if (!yymatchString(G, "end")) goto l25;
  yyprintf((stderr, "  ok   end_kw"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l25:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "end_kw"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_scope(GREG *G)
{  yyprintfv((stderr, "%s\n", "scope"));

  l27:;	
  {  int yypos28= G->pos, yythunkpos28= G->thunkpos;  if (!yy_WS(G))  goto l28;
  if (!yy_expression(G))  goto l28;
  if (!yy_WS(G))  goto l28;
  goto l27;
  l28:;	  G->pos= yypos28; G->thunkpos= yythunkpos28;
  }  yyprintf((stderr, "  ok   scope"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
}
YY_RULE(int) yy_arg_list(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "arg_list"));
  if (!yymatchChar(G, '(')) goto l29;
  if (!yy_WS(G))  goto l29;

  {  int yypos30= G->pos, yythunkpos30= G->thunkpos;  if (!yy_arg(G))  goto l30;
  if (!yy_WS(G))  goto l30;

  l32:;	
  {  int yypos33= G->pos, yythunkpos33= G->thunkpos;  if (!yymatchChar(G, ',')) goto l33;
  if (!yy_WS(G))  goto l33;
  if (!yy_arg(G))  goto l33;
  if (!yy_WS(G))  goto l33;
  goto l32;
  l33:;	  G->pos= yypos33; G->thunkpos= yythunkpos33;
  }  goto l31;
  l30:;	  G->pos= yypos30; G->thunkpos= yythunkpos30;
  }
  l31:;	  if (!yy_WS(G))  goto l29;
  if (!yy_clos_paren(G)) {  { YY_XTYPE YY_XVAR = (YY_XTYPE) G->data; int yyindex = G->offset + G->pos;  throwError(PPE_EXP_ARG, bfromcstr("Malformed function argument")) ; } goto l29; }
  yyprintf((stderr, "  ok   arg_list"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l29:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "arg_list"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_ID(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "ID"));

  {  int yypos35= G->pos, yythunkpos35= G->thunkpos;  if (!yy_kw(G))  goto l35;
  goto l34;
  l35:;	  G->pos= yypos35; G->thunkpos= yythunkpos35;
  }  yyText(G, G->begin, G->end);  if (!(YY_BEGIN)) goto l34;  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "a-zA-Z0-9_")) goto l34;

  l36:;	
  {  int yypos37= G->pos, yythunkpos37= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\000\000\000\000\000\000\377\003\376\377\377\207\376\377\377\007\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", "a-zA-Z0-9_")) goto l37;
  goto l36;
  l37:;	  G->pos= yypos37; G->thunkpos= yythunkpos37;
  }  yyText(G, G->begin, G->end);  if (!(YY_END)) goto l34;  yyDo(G, yy_1_ID, G->begin, G->end, "yy_1_ID");
  yyprintf((stderr, "  ok   ID"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l34:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "ID"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy__(GREG *G)
{  yyprintfv((stderr, "%s\n", "_"));

  l39:;	
  {  int yypos40= G->pos, yythunkpos40= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", " \\t")) goto l40;
  goto l39;
  l40:;	  G->pos= yypos40; G->thunkpos= yythunkpos40;
  }  yyprintf((stderr, "  ok   _"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
}
YY_RULE(int) yy_func_decl(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyDo(G, yyPush, 1, 0, "yyPush");
  yyprintfv((stderr, "%s\n", "func_decl"));
  if (!yymatchString(G, "def")) goto l41;
  if (!yy__(G))  goto l41;
  if (!yy_ID(G))  goto l41;
  yyDo(G, yySet, -1, 0, "yySet");
  yyDo(G, yy_1_func_decl, G->begin, G->end, "yy_1_func_decl");
  if (!yy__(G))  goto l41;

  {  int yypos42= G->pos, yythunkpos42= G->thunkpos;  if (!yy_arg_list(G))  goto l42;
  goto l43;
  l42:;	  G->pos= yypos42; G->thunkpos= yythunkpos42;
  }
  l43:;	  if (!yy__(G))  goto l41;
  if (!yy_EOL(G))  goto l41;
  if (!yy__(G))  goto l41;
  if (!yy_scope(G))  goto l41;
  if (!yy__(G))  goto l41;
  if (!yy_end_kw(G)) {  { YY_XTYPE YY_XVAR = (YY_XTYPE) G->data; int yyindex = G->offset + G->pos;  throwError(PPE_EXP_STAT, bfromcstr("Expected statement")) ; } goto l41; }
  yyDo(G, yy_2_func_decl, G->begin, G->end, "yy_2_func_decl");
  yyprintf((stderr, "  ok   func_decl"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));
  yyDo(G, yyPop, 1, 0, "yyPop");
  return 1;
  l41:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "func_decl"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_EOL(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "EOL"));

  {  int yypos45= G->pos, yythunkpos45= G->thunkpos;  if (!yymatchChar(G, '\n')) goto l46;
  goto l45;
  l46:;	  G->pos= yypos45; G->thunkpos= yythunkpos45;  if (!yymatchString(G, "\r\n")) goto l47;
  goto l45;
  l47:;	  G->pos= yypos45; G->thunkpos= yythunkpos45;  if (!yymatchChar(G, '\r')) goto l48;
  goto l45;
  l48:;	  G->pos= yypos45; G->thunkpos= yythunkpos45;  if (!yymatchChar(G, ';')) goto l44;

  }
  l45:;	  yyprintf((stderr, "  ok   EOL"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l44:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "EOL"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_WS(GREG *G)
{  yyprintfv((stderr, "%s\n", "WS"));

  l50:;	
  {  int yypos51= G->pos, yythunkpos51= G->thunkpos;
  {  int yypos52= G->pos, yythunkpos52= G->thunkpos;  if (!yymatchClass(G, (const unsigned char *)"\000\002\000\000\001\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000", " \\t")) goto l53;
  goto l52;
  l53:;	  G->pos= yypos52; G->thunkpos= yythunkpos52;  if (!yy_EOL(G))  goto l51;

  }
  l52:;	  goto l50;
  l51:;	  G->pos= yypos51; G->thunkpos= yythunkpos51;
  }  yyprintf((stderr, "  ok   WS"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
}
YY_RULE(int) yy_module_core(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "module_core"));
  if (!yy_WS(G))  goto l54;
  if (!yy_func_decl(G))  goto l54;
  if (!yy_WS(G))  goto l54;
  yyprintf((stderr, "  ok   module_core"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l54:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "module_core"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}
YY_RULE(int) yy_module(GREG *G)
{  int yypos0= G->pos, yythunkpos0= G->thunkpos;  yyprintfv((stderr, "%s\n", "module"));

  {  int yypos56= G->pos, yythunkpos56= G->thunkpos;  if (!yy_module_core(G))  goto l57;
  goto l56;
  l57:;	  G->pos= yypos56; G->thunkpos= yythunkpos56;  if (!yy_WS(G))  goto l55;

  l58:;	
  {  int yypos59= G->pos, yythunkpos59= G->thunkpos;
  {  int yypos60= G->pos, yythunkpos60= G->thunkpos;  if (!yy_EOL(G))  goto l60;
  goto l59;
  l60:;	  G->pos= yypos60; G->thunkpos= yythunkpos60;
  }  if (!yymatchDot(G)) goto l59;  goto l58;
  l59:;	  G->pos= yypos59; G->thunkpos= yythunkpos59;
  }  if (!yy_EOL(G))  goto l55;
  yyDo(G, yy_1_module, G->begin, G->end, "yy_1_module");

  }
  l56:;	  yyprintf((stderr, "  ok   module"));
  yyprintfGcontext;
  yyprintf((stderr, "\n"));

  return 1;
  l55:;	  G->pos= yypos0; G->thunkpos= yythunkpos0;  yyprintfv((stderr, "  fail %s", "module"));
  yyprintfvGcontext;
  yyprintfv((stderr, "\n"));

  return 0;
}

#ifndef YY_PART

typedef int (*yyrule)(GREG *G);

YY_PARSE(int) YY_NAME(parse_from)(GREG *G, yyrule yystart)
{
  int yyok;
  if (!G->buflen)
    {
      G->buflen= YY_BUFFER_START_SIZE;
      G->buf= (char*)YY_ALLOC(G->buflen, G->data);
      G->textlen= YY_BUFFER_START_SIZE;
      G->text= (char*)YY_ALLOC(G->textlen, G->data);
      G->thunkslen= YY_STACK_SIZE;
      G->thunks= (yythunk*)YY_ALLOC(sizeof(yythunk) * G->thunkslen, G->data);
      G->valslen= YY_STACK_SIZE;
      G->vals= (YYSTYPE*)YY_ALLOC(sizeof(YYSTYPE) * G->valslen, G->data);
      G->begin= G->end= G->pos= G->limit= G->thunkpos= 0;
    }
  G->pos = 0;
  G->begin= G->end= G->pos;
  G->thunkpos= 0;
  G->val= G->vals;
  yyok= yystart(G);
  if (yyok) yyDone(G);
  yyCommit(G);
  return yyok;
  (void)yyrefill;
  (void)yymatchDot;
  (void)yymatchChar;
  (void)yymatchString;
  (void)yymatchClass;
  (void)yyDo;
  (void)yyText;
  (void)yyDone;
  (void)yyCommit;
  (void)yyAccept;
  (void)yyPush;
  (void)yyPop;
  (void)yySet;
}

YY_PARSE(int) YY_NAME(parse)(GREG *G)
{
  return YY_NAME(parse_from)(G, yy_module);
}

YY_PARSE(void) YY_NAME(init)(GREG *G)
{
    memset(G, 0, sizeof(GREG));
}
YY_PARSE(void) YY_NAME(deinit)(GREG *G)
{
    if (G->buf) YY_FREE(G->buf);
    if (G->text) YY_FREE(G->text);
    if (G->thunks) YY_FREE(G->thunks);
    if (G->vals) YY_FREE((void*)G->vals);
}
YY_PARSE(GREG *) YY_NAME(parse_new)(YY_XTYPE data)
{
  GREG *G = (GREG *)YY_CALLOC(1, sizeof(GREG), G->data);
  G->data = data;
  return G;
}

YY_PARSE(void) YY_NAME(parse_free)(GREG *G)
{
  YY_NAME(deinit)(G);
  YY_FREE(G);
}

#endif


///////////////////// IO interface: supports memory + files ////////////////////////

void pug_parser_yyinput(char *buf, int *result, int max_size, pug_parser_core *core) {
    (*result) = core->io.read(buf, max_size, core);
    if((*result) == 0 && core->eof == 0) {
        core->eof = 1;
        (*buf) = '\n';
        (*result) = 1;
        return;
    }
    for(int i = 0; i < (*result) - 1; i++) {
        // if we encounter a line separation ('\' followed by EOL),
        // replace both the '\' and the EOL (CRLF or LF) with spaces -
        // it won't hurt the parsing and is faster than memmov-ing the
        // rest of the buffer in place.
        if(buf[i] == '\\') {
            if(buf[i+1] == '\r') {
                buf[i] = ' ';
                buf[i+1] = ' ';
                if(buf[i+2] == '\n') {
                    // CRLF (Win32)
                    buf[i+2] = ' ';
                    i += 2; continue;
                }
                // CR (AIX?)
                i += 1; continue;
            } else if(buf[i+1] == '\n') {
                // LF (Linux, Mac)
                buf[i] = ' ';
                buf[i+1] = ' ';
                i += 1; continue;
            }
        }
    }
}

static int _pug_parser_memread(void *ptr, size_t size, pug_parser_core *core) {
    char *source = (char *) core->stream;
    size_t tocopy = size;
    size_t remaining = core->streamlen - core->streamoffset;
    if (tocopy > remaining) {
      tocopy = remaining;
    }
    memcpy(ptr, source + core->streamoffset, tocopy);
    core->streamoffset += tocopy;
    return (int) tocopy;
}

static int _pug_parser_fread(void *ptr, size_t size, pug_parser_core *core) {
    FILE *stream = (FILE *) core->stream;
    return fread(ptr, 1, size, (FILE*) stream);
}


int pug_parser_memparse(void *this, char *buffer, ssize_t len) {

    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    G->buflen = 0;

    pug_parser_core *core = YY_ALLOC(sizeof(pug_parser_core), 0);
    core->yylineno = 0;
    core->eof = 0;
    core->this = this;
    core->path = NULL;
    core->stream = buffer;
    core->streamoffset = 0;
    core->streamlen = len;
    if(!core->stream) {
        printf("Null input buffer\n");
        return -1;
    }
    if(len < 0) {
        printf("Invalid input buffer length\n");
        return -1;
    }
    pug_parser_set_token_position_pointer(this, core->token, &(core->yylineno));
    core->io = (struct _pug_parser_io) {
      (_pug_parser_io_read)_pug_parser_memread
    };

    G->data = core;

    while (yyparse(G)) {}

    return 0;

}

int pug_parser_parse(void *this, bstring path) {
    GREG *G = YY_ALLOC(sizeof(GREG), 0);
    G->buflen = 0;

    pug_parser_core *core = YY_ALLOC(sizeof(pug_parser_core), 0);
    core->yylineno = 0;
    core->eof = 0;
    core->this = this;
    core->path = path;

#if defined(__WIN32__) || defined(__WIN64__)
    // we need to use binary mode because text mode on MinGW
    // does CR->LF conversion and we handle that ourselves.
    core->stream = fopen(bdata(path), "rb");
#else
    core->stream = fopen(bdata(path), "r");
#endif

    core->streamoffset = -1;
    core->streamlen = -1;
    if(!core->stream) {
        printf("Not found: %s\n", bdata(path));
        return -1;
    }
    pug_parser_set_token_position_pointer(this, core->token, &(core->yylineno));
    core->io = (struct _pug_parser_io) {
      (_pug_parser_io_read)_pug_parser_fread
    };

    G->data = core;

    while (yyparse(G)) {}
    fclose(core->stream);

    return 0;

}


